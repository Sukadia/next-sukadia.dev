"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-client_app_space_BabylonScene_tsx"],{

/***/ "(app-client)/./app/space/BabylonScene.tsx":
/*!************************************!*\
  !*** ./app/space/BabylonScene.tsx ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ BabylonScene; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-client)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _babylonjs_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babylonjs/core */ \"(app-client)/./node_modules/@babylonjs/core/index.js\");\n/* harmony import */ var _BabylonInteractivity__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BabylonInteractivity */ \"(app-client)/./app/space/BabylonInteractivity.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\n\n\nclass BabylonScene extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {\n    componentDidMount() {\n        console.clear();\n        this.setup(this.canvas);\n    }\n    render() {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n                id: this.id,\n                ref: this.onMount,\n                style: style\n            }, void 0, false, {\n                fileName: \"X:\\\\Some Useful Stuff\\\\Applications\\\\Web\\\\next-sukadia.dev\\\\app\\\\space\\\\BabylonScene.tsx\",\n                lineNumber: 170,\n                columnNumber: 9\n            }, this)\n        }, void 0, false);\n    }\n    constructor(...args){\n        super(...args);\n        this.setup = async (canvas)=>{\n            _babylonjs_core__WEBPACK_IMPORTED_MODULE_2__.ShaderStore.ShadersStoreWGSL[\"starsPixelShader\"] = \"\\n        uniform seed : f32;\\n        uniform density : f32;\\n        uniform brightness : f32;\\n\\n        fn rand(seed : vec2<f32>) -> f32 {\\n            return fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453);\\n        }\\n\\n        @fragment\\n        fn main(input : FragmentInputs) -> FragmentOutputs {\\n\\n            let random = rand(input.vUV*uniforms.seed);\\n            var brightness = 0.0;\\n            if (random < uniforms.density){\\n                brightness = random/uniforms.density*uniforms.brightness;\\n            }\\n            //fragmentOutputs.color = vec4(1., 1., 1., brightness);\\n            fragmentOutputs.color = vec4(brightness, brightness, brightness, 1.);\\n        }\\n    \";\n            _babylonjs_core__WEBPACK_IMPORTED_MODULE_2__.ShaderStore.ShadersStoreWGSL[\"nebulasPixelShader\"] = \"\\n        var textureSampler: texture_2d<f32>;\\n        var textureSamplerSampler: sampler;\\n\\n        uniform seed: f32;\\n        uniform color: vec4<f32>;\\n        uniform nebulascale: u32;\\n        uniform depth: u32;\\n        uniform intensity: f32;\\n        uniform falloff: f32;\\n        uniform persistence: f32;\\n\\n        fn mod289(x: vec2<f32>) -> vec2<f32> {\\n            return x - floor(x * (1. / 289.)) * 289.;\\n        }\\n        \\n        fn mod289_3(x: vec3<f32>) -> vec3<f32> {\\n            return x - floor(x * (1. / 289.)) * 289.;\\n        }\\n        \\n        fn permute3(x: vec3<f32>) -> vec3<f32> {\\n            return mod289_3(((x * 34.) + 1.) * x);\\n        }\\n        \\n        //  MIT License. \\xa9 Ian McEwan, Stefan Gustavson, Munrocket\\n        fn simplexNoise2(v: vec2<f32>) -> f32 {\\n            let C = vec4(\\n                0.211324865405187, // (3.0-sqrt(3.0))/6.0\\n                0.366025403784439, // 0.5*(sqrt(3.0)-1.0)\\n                -0.577350269189626, // -1.0 + 2.0 * C.x\\n                0.024390243902439 // 1.0 / 41.0\\n            );\\n        \\n            // First corner\\n            var i = floor(v + dot(v, C.yy));\\n            let x0 = v - i + dot(i, C.xx);\\n        \\n            // Other corners\\n            var i1 = select(vec2(0., 1.), vec2(1., 0.), x0.x > x0.y);\\n        \\n            // x0 = x0 - 0.0 + 0.0 * C.xx ;\\n            // x1 = x0 - i1 + 1.0 * C.xx ;\\n            // x2 = x0 - 1.0 + 2.0 * C.xx ;\\n            var x12 = x0.xyxy + C.xxzz;\\n            x12.x = x12.x - i1.x;\\n            x12.y = x12.y - i1.y;\\n        \\n            // Permutations\\n            i = mod289(i); // Avoid truncation effects in permutation\\n        \\n            var p = permute3(permute3(i.y + vec3(0., i1.y, 1.)) + i.x + vec3(0., i1.x, 1.));\\n            var m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), vec3(0.));\\n            m *= m;\\n            m *= m;\\n        \\n            // Gradients: 41 points uniformly over a line, mapped onto a diamond.\\n            // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\\n            let x = 2. * fract(p * C.www) - 1.;\\n            let h = abs(x) - 0.5;\\n            let ox = floor(x + 0.5);\\n            let a0 = x - ox;\\n        \\n            // Normalize gradients implicitly by scaling m\\n            // Approximation of: m *= inversesqrt( a0*a0 + h*h );\\n            m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\\n        \\n            // Compute final noise value at P\\n            let g = vec3(a0.x * x0.x + h.x * x0.y, a0.yz * x12.xz + h.yz * x12.yw);\\n            return 130. * dot(m, g);\\n        }\\n\\n        fn normalNoise(v: vec2<f32>) -> f32 {\\n            return simplexNoise2(v)*0.5 + 0.5;\\n        }\\n\\n        @fragment\\n        fn main(input : FragmentInputs) -> FragmentOutputs {\\n            let sampleColor = textureSample(textureSampler,textureSamplerSampler,fragmentInputs.vUV);\\n\\n            var offset = 0.;\\n            let scaledUV = (input.vUV+offset+uniforms.seed)*f32(uniforms.nebulascale)/uniforms.scale;\\n\\n            var displace = 0.;\\n            var i=u32(0);\\n            for (i=0; i<uniforms.depth; i++){\\n                displace = normalNoise(scaledUV*pow(uniforms.persistence,f32(i+1))+displace);\\n            }\\n            var finalTransparency = normalNoise(scaledUV+displace);\\n            finalTransparency = pow(max(finalTransparency+uniforms.intensity,0), uniforms.falloff);\\n\\n            fragmentOutputs.color = mix(sampleColor,uniforms.color,finalTransparency);\\n        }\\n    \";\n            const engine = await this.createEngine(canvas);\n            const scene = new _babylonjs_core__WEBPACK_IMPORTED_MODULE_2__.Scene(engine);\n            scene.clearColor = new _babylonjs_core__WEBPACK_IMPORTED_MODULE_2__.Color4(0, 0, 0, 0);\n            const camera = new _babylonjs_core__WEBPACK_IMPORTED_MODULE_2__.ArcRotateCamera(\"camera\", 0, 0, 0, new _babylonjs_core__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, 0), scene);\n            _BabylonInteractivity__WEBPACK_IMPORTED_MODULE_3__[\"default\"].initialize(canvas, engine, scene, camera);\n            _BabylonInteractivity__WEBPACK_IMPORTED_MODULE_3__[\"default\"].generateFrame();\n        };\n        this.createEngine = async (canvas)=>{\n            let engine;\n            if (await _babylonjs_core__WEBPACK_IMPORTED_MODULE_2__.WebGPUEngine.IsSupportedAsync) {\n                engine = new _babylonjs_core__WEBPACK_IMPORTED_MODULE_2__.WebGPUEngine(canvas);\n                await engine.initAsync();\n            } else {\n                console.log(\"WebGPU is not supported (or turned on) for this browser!\");\n                engine = new _babylonjs_core__WEBPACK_IMPORTED_MODULE_2__.WebGPUEngine(canvas);\n            }\n            return engine;\n        };\n        this.id = \"Babylon\";\n        this.onMount = (canvas)=>this.canvas = canvas;\n    }\n}\n/**\r\n * Babylon 3D Scene.\r\n */ \nconst style = {\n    width: window.innerWidth,\n    height: window.innerHeight,\n    background: \"transparent\"\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vYXBwL3NwYWNlL0JhYnlsb25TY2VuZS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUM0QztBQVNwQjtBQUNpQztBQUsxQyxNQUFNUyxxQkFBcUJSLGdEQUFhQTtJQUNyRFMsb0JBQW9CO1FBQ2xCQyxRQUFRQztRQUNSLElBQUksQ0FBQ0MsTUFBTSxJQUFJLENBQUNDO0lBQ2xCO0lBa0pBQyxTQUFTO1FBQ1AscUJBQ0U7c0JBQ0UsNEVBQUNEO2dCQUFPRSxJQUFJLElBQUksQ0FBQ0E7Z0JBQUlDLEtBQUssSUFBSSxDQUFDQztnQkFBU0MsT0FBT0E7Ozs7Ozs7SUFHckQ7OzthQXRKQU4sUUFBUSxPQUFPQztZQUNiUix3REFBV0EsQ0FBQ2MsZ0JBQWdCLENBQUMsbUJBQW1CLEdBQUk7WUFzQnBEZCx3REFBV0EsQ0FBQ2MsZ0JBQWdCLENBQUMscUJBQXFCLEdBQUk7WUE4RnRELE1BQU1DLFNBQVMsTUFBTSxJQUFJLENBQUNDLGFBQWFSO1lBQ3ZDLE1BQU1TLFFBQVEsSUFBSXBCLGtEQUFLQSxDQUFDa0I7WUFDeEJFLE1BQU1DLGFBQWEsSUFBSWpCLG1EQUFNQSxDQUFDLEdBQUUsR0FBRSxHQUFFO1lBQ3BDLE1BQU1rQixTQUFTLElBQUl2Qiw0REFBZUEsQ0FBQyxVQUFVLEdBQUcsR0FBRyxHQUFHLElBQUlHLG9EQUFPQSxDQUFDLEdBQUcsR0FBRyxJQUFJa0I7WUFFNUVmLDZEQUFvQkEsQ0FBQ2tCLFdBQVdaLFFBQU9PLFFBQU9FLE9BQU1FO1lBRXBEakIsNkRBQW9CQSxDQUFDbUI7UUFDdkI7YUFFQUwsZUFBZSxPQUFPUjtZQUNwQixJQUFJTztZQUNKLElBQUksTUFBTWpCLHlEQUFZQSxDQUFDd0Isa0JBQWlCO2dCQUN0Q1AsU0FBUyxJQUFJakIseURBQVlBLENBQUNVO2dCQUMxQixNQUFNLE9BQXlCZTtZQUNqQyxPQUFLO2dCQUNIbEIsUUFBUW1CLElBQUk7Z0JBQ1pULFNBQVMsSUFBSWpCLHlEQUFZQSxDQUFDVTtZQUM1QjtZQUNBLE9BQU9PO1FBQ1Q7YUFFQUwsS0FBSzthQUdMRSxVQUFVLENBQUNKLFNBQStCLElBQUksQ0FBQ0EsU0FBU0E7O0FBUzFEO0FBaEtBOztDQUVDLEdBOEpBO0FBRUQsTUFBTUssUUFBUTtJQUFFWSxPQUFPQyxPQUFPQztJQUFZQyxRQUFRRixPQUFPRztJQUFhQyxZQUFZO0FBQWMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL3NwYWNlL0JhYnlsb25TY2VuZS50c3g/N2VkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIlxyXG5pbXBvcnQgUmVhY3QsIHsgUHVyZUNvbXBvbmVudCB9IGZyb20gXCJyZWFjdFwiXHJcbmltcG9ydCB7XHJcbiAgQXJjUm90YXRlQ2FtZXJhLFxyXG4gIFNjZW5lLFxyXG4gIEVuZ2luZSxcclxuICBXZWJHUFVFbmdpbmUsXHJcbiAgVmVjdG9yMyxcclxuICBTaGFkZXJTdG9yZSxcclxuICBDb2xvcjRcclxufSBmcm9tIFwiQGJhYnlsb25qcy9jb3JlXCJcclxuaW1wb3J0IEJhYnlsb25JbnRlcmFjdGl2aXR5IGZyb20gXCIuL0JhYnlsb25JbnRlcmFjdGl2aXR5XCJcclxuXHJcbi8qKlxyXG4gKiBCYWJ5bG9uIDNEIFNjZW5lLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFieWxvblNjZW5lIGV4dGVuZHMgUHVyZUNvbXBvbmVudCB7XHJcbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XHJcbiAgICBjb25zb2xlLmNsZWFyKClcclxuICAgIHRoaXMuc2V0dXAodGhpcy5jYW52YXMpXHJcbiAgfVxyXG5cclxuICBzZXR1cCA9IGFzeW5jIChjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSA9PiB7XHJcbiAgICBTaGFkZXJTdG9yZS5TaGFkZXJzU3RvcmVXR1NMW1wic3RhcnNQaXhlbFNoYWRlclwiXSA9IGBcclxuICAgICAgICB1bmlmb3JtIHNlZWQgOiBmMzI7XHJcbiAgICAgICAgdW5pZm9ybSBkZW5zaXR5IDogZjMyO1xyXG4gICAgICAgIHVuaWZvcm0gYnJpZ2h0bmVzcyA6IGYzMjtcclxuXHJcbiAgICAgICAgZm4gcmFuZChzZWVkIDogdmVjMjxmMzI+KSAtPiBmMzIge1xyXG4gICAgICAgICAgICByZXR1cm4gZnJhY3Qoc2luKGRvdChzZWVkLCB2ZWMyKDEyLjk4OTgsIDc4LjIzMykpKSAqIDQzNzU4LjU0NTMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgQGZyYWdtZW50XHJcbiAgICAgICAgZm4gbWFpbihpbnB1dCA6IEZyYWdtZW50SW5wdXRzKSAtPiBGcmFnbWVudE91dHB1dHMge1xyXG5cclxuICAgICAgICAgICAgbGV0IHJhbmRvbSA9IHJhbmQoaW5wdXQudlVWKnVuaWZvcm1zLnNlZWQpO1xyXG4gICAgICAgICAgICB2YXIgYnJpZ2h0bmVzcyA9IDAuMDtcclxuICAgICAgICAgICAgaWYgKHJhbmRvbSA8IHVuaWZvcm1zLmRlbnNpdHkpe1xyXG4gICAgICAgICAgICAgICAgYnJpZ2h0bmVzcyA9IHJhbmRvbS91bmlmb3Jtcy5kZW5zaXR5KnVuaWZvcm1zLmJyaWdodG5lc3M7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9mcmFnbWVudE91dHB1dHMuY29sb3IgPSB2ZWM0KDEuLCAxLiwgMS4sIGJyaWdodG5lc3MpO1xyXG4gICAgICAgICAgICBmcmFnbWVudE91dHB1dHMuY29sb3IgPSB2ZWM0KGJyaWdodG5lc3MsIGJyaWdodG5lc3MsIGJyaWdodG5lc3MsIDEuKTtcclxuICAgICAgICB9XHJcbiAgICBgXHJcblxyXG4gICAgU2hhZGVyU3RvcmUuU2hhZGVyc1N0b3JlV0dTTFtcIm5lYnVsYXNQaXhlbFNoYWRlclwiXSA9IGBcclxuICAgICAgICB2YXIgdGV4dHVyZVNhbXBsZXI6IHRleHR1cmVfMmQ8ZjMyPjtcclxuICAgICAgICB2YXIgdGV4dHVyZVNhbXBsZXJTYW1wbGVyOiBzYW1wbGVyO1xyXG5cclxuICAgICAgICB1bmlmb3JtIHNlZWQ6IGYzMjtcclxuICAgICAgICB1bmlmb3JtIGNvbG9yOiB2ZWM0PGYzMj47XHJcbiAgICAgICAgdW5pZm9ybSBuZWJ1bGFzY2FsZTogdTMyO1xyXG4gICAgICAgIHVuaWZvcm0gZGVwdGg6IHUzMjtcclxuICAgICAgICB1bmlmb3JtIGludGVuc2l0eTogZjMyO1xyXG4gICAgICAgIHVuaWZvcm0gZmFsbG9mZjogZjMyO1xyXG4gICAgICAgIHVuaWZvcm0gcGVyc2lzdGVuY2U6IGYzMjtcclxuXHJcbiAgICAgICAgZm4gbW9kMjg5KHg6IHZlYzI8ZjMyPikgLT4gdmVjMjxmMzI+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuIC8gMjg5LikpICogMjg5LjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm4gbW9kMjg5XzMoeDogdmVjMzxmMzI+KSAtPiB2ZWMzPGYzMj4ge1xyXG4gICAgICAgICAgICByZXR1cm4geCAtIGZsb29yKHggKiAoMS4gLyAyODkuKSkgKiAyODkuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBmbiBwZXJtdXRlMyh4OiB2ZWMzPGYzMj4pIC0+IHZlYzM8ZjMyPiB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb2QyODlfMygoKHggKiAzNC4pICsgMS4pICogeCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vICBNSVQgTGljZW5zZS4gwqkgSWFuIE1jRXdhbiwgU3RlZmFuIEd1c3RhdnNvbiwgTXVucm9ja2V0XHJcbiAgICAgICAgZm4gc2ltcGxleE5vaXNlMih2OiB2ZWMyPGYzMj4pIC0+IGYzMiB7XHJcbiAgICAgICAgICAgIGxldCBDID0gdmVjNChcclxuICAgICAgICAgICAgICAgIDAuMjExMzI0ODY1NDA1MTg3LCAvLyAoMy4wLXNxcnQoMy4wKSkvNi4wXHJcbiAgICAgICAgICAgICAgICAwLjM2NjAyNTQwMzc4NDQzOSwgLy8gMC41KihzcXJ0KDMuMCktMS4wKVxyXG4gICAgICAgICAgICAgICAgLTAuNTc3MzUwMjY5MTg5NjI2LCAvLyAtMS4wICsgMi4wICogQy54XHJcbiAgICAgICAgICAgICAgICAwLjAyNDM5MDI0MzkwMjQzOSAvLyAxLjAgLyA0MS4wXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEZpcnN0IGNvcm5lclxyXG4gICAgICAgICAgICB2YXIgaSA9IGZsb29yKHYgKyBkb3QodiwgQy55eSkpO1xyXG4gICAgICAgICAgICBsZXQgeDAgPSB2IC0gaSArIGRvdChpLCBDLnh4KTtcclxuICAgICAgICBcclxuICAgICAgICAgICAgLy8gT3RoZXIgY29ybmVyc1xyXG4gICAgICAgICAgICB2YXIgaTEgPSBzZWxlY3QodmVjMigwLiwgMS4pLCB2ZWMyKDEuLCAwLiksIHgwLnggPiB4MC55KTtcclxuICAgICAgICBcclxuICAgICAgICAgICAgLy8geDAgPSB4MCAtIDAuMCArIDAuMCAqIEMueHggO1xyXG4gICAgICAgICAgICAvLyB4MSA9IHgwIC0gaTEgKyAxLjAgKiBDLnh4IDtcclxuICAgICAgICAgICAgLy8geDIgPSB4MCAtIDEuMCArIDIuMCAqIEMueHggO1xyXG4gICAgICAgICAgICB2YXIgeDEyID0geDAueHl4eSArIEMueHh6ejtcclxuICAgICAgICAgICAgeDEyLnggPSB4MTIueCAtIGkxLng7XHJcbiAgICAgICAgICAgIHgxMi55ID0geDEyLnkgLSBpMS55O1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgICAvLyBQZXJtdXRhdGlvbnNcclxuICAgICAgICAgICAgaSA9IG1vZDI4OShpKTsgLy8gQXZvaWQgdHJ1bmNhdGlvbiBlZmZlY3RzIGluIHBlcm11dGF0aW9uXHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBwID0gcGVybXV0ZTMocGVybXV0ZTMoaS55ICsgdmVjMygwLiwgaTEueSwgMS4pKSArIGkueCArIHZlYzMoMC4sIGkxLngsIDEuKSk7XHJcbiAgICAgICAgICAgIHZhciBtID0gbWF4KDAuNSAtIHZlYzMoZG90KHgwLCB4MCksIGRvdCh4MTIueHksIHgxMi54eSksIGRvdCh4MTIuencsIHgxMi56dykpLCB2ZWMzKDAuKSk7XHJcbiAgICAgICAgICAgIG0gKj0gbTtcclxuICAgICAgICAgICAgbSAqPSBtO1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgICAvLyBHcmFkaWVudHM6IDQxIHBvaW50cyB1bmlmb3JtbHkgb3ZlciBhIGxpbmUsIG1hcHBlZCBvbnRvIGEgZGlhbW9uZC5cclxuICAgICAgICAgICAgLy8gVGhlIHJpbmcgc2l6ZSAxNyoxNyA9IDI4OSBpcyBjbG9zZSB0byBhIG11bHRpcGxlIG9mIDQxICg0MSo3ID0gMjg3KVxyXG4gICAgICAgICAgICBsZXQgeCA9IDIuICogZnJhY3QocCAqIEMud3d3KSAtIDEuO1xyXG4gICAgICAgICAgICBsZXQgaCA9IGFicyh4KSAtIDAuNTtcclxuICAgICAgICAgICAgbGV0IG94ID0gZmxvb3IoeCArIDAuNSk7XHJcbiAgICAgICAgICAgIGxldCBhMCA9IHggLSBveDtcclxuICAgICAgICBcclxuICAgICAgICAgICAgLy8gTm9ybWFsaXplIGdyYWRpZW50cyBpbXBsaWNpdGx5IGJ5IHNjYWxpbmcgbVxyXG4gICAgICAgICAgICAvLyBBcHByb3hpbWF0aW9uIG9mOiBtICo9IGludmVyc2VzcXJ0KCBhMCphMCArIGgqaCApO1xyXG4gICAgICAgICAgICBtICo9IDEuNzkyODQyOTE0MDAxNTkgLSAwLjg1MzczNDcyMDk1MzE0ICogKGEwICogYTAgKyBoICogaCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgZmluYWwgbm9pc2UgdmFsdWUgYXQgUFxyXG4gICAgICAgICAgICBsZXQgZyA9IHZlYzMoYTAueCAqIHgwLnggKyBoLnggKiB4MC55LCBhMC55eiAqIHgxMi54eiArIGgueXogKiB4MTIueXcpO1xyXG4gICAgICAgICAgICByZXR1cm4gMTMwLiAqIGRvdChtLCBnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZuIG5vcm1hbE5vaXNlKHY6IHZlYzI8ZjMyPikgLT4gZjMyIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNpbXBsZXhOb2lzZTIodikqMC41ICsgMC41O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgQGZyYWdtZW50XHJcbiAgICAgICAgZm4gbWFpbihpbnB1dCA6IEZyYWdtZW50SW5wdXRzKSAtPiBGcmFnbWVudE91dHB1dHMge1xyXG4gICAgICAgICAgICBsZXQgc2FtcGxlQ29sb3IgPSB0ZXh0dXJlU2FtcGxlKHRleHR1cmVTYW1wbGVyLHRleHR1cmVTYW1wbGVyU2FtcGxlcixmcmFnbWVudElucHV0cy52VVYpO1xyXG5cclxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IDAuO1xyXG4gICAgICAgICAgICBsZXQgc2NhbGVkVVYgPSAoaW5wdXQudlVWK29mZnNldCt1bmlmb3Jtcy5zZWVkKSpmMzIodW5pZm9ybXMubmVidWxhc2NhbGUpL3VuaWZvcm1zLnNjYWxlO1xyXG5cclxuICAgICAgICAgICAgdmFyIGRpc3BsYWNlID0gMC47XHJcbiAgICAgICAgICAgIHZhciBpPXUzMigwKTtcclxuICAgICAgICAgICAgZm9yIChpPTA7IGk8dW5pZm9ybXMuZGVwdGg7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGFjZSA9IG5vcm1hbE5vaXNlKHNjYWxlZFVWKnBvdyh1bmlmb3Jtcy5wZXJzaXN0ZW5jZSxmMzIoaSsxKSkrZGlzcGxhY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBmaW5hbFRyYW5zcGFyZW5jeSA9IG5vcm1hbE5vaXNlKHNjYWxlZFVWK2Rpc3BsYWNlKTtcclxuICAgICAgICAgICAgZmluYWxUcmFuc3BhcmVuY3kgPSBwb3cobWF4KGZpbmFsVHJhbnNwYXJlbmN5K3VuaWZvcm1zLmludGVuc2l0eSwwKSwgdW5pZm9ybXMuZmFsbG9mZik7XHJcblxyXG4gICAgICAgICAgICBmcmFnbWVudE91dHB1dHMuY29sb3IgPSBtaXgoc2FtcGxlQ29sb3IsdW5pZm9ybXMuY29sb3IsZmluYWxUcmFuc3BhcmVuY3kpO1xyXG4gICAgICAgIH1cclxuICAgIGBcclxuXHJcbiAgICBjb25zdCBlbmdpbmUgPSBhd2FpdCB0aGlzLmNyZWF0ZUVuZ2luZShjYW52YXMpXHJcbiAgICBjb25zdCBzY2VuZSA9IG5ldyBTY2VuZShlbmdpbmUpXHJcbiAgICBzY2VuZS5jbGVhckNvbG9yID0gbmV3IENvbG9yNCgwLDAsMCwwKVxyXG4gICAgY29uc3QgY2FtZXJhID0gbmV3IEFyY1JvdGF0ZUNhbWVyYShcImNhbWVyYVwiLCAwLCAwLCAwLCBuZXcgVmVjdG9yMygwLCAwLCAwKSwgc2NlbmUpO1xyXG5cclxuICAgIEJhYnlsb25JbnRlcmFjdGl2aXR5LmluaXRpYWxpemUoY2FudmFzLGVuZ2luZSxzY2VuZSxjYW1lcmEpXHJcblxyXG4gICAgQmFieWxvbkludGVyYWN0aXZpdHkuZ2VuZXJhdGVGcmFtZSgpXHJcbiAgfVxyXG5cclxuICBjcmVhdGVFbmdpbmUgPSBhc3luYyAoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkgPT4ge1xyXG4gICAgbGV0IGVuZ2luZTogV2ViR1BVRW5naW5lIHwgRW5naW5lXHJcbiAgICBpZiAoYXdhaXQgV2ViR1BVRW5naW5lLklzU3VwcG9ydGVkQXN5bmMpe1xyXG4gICAgICBlbmdpbmUgPSBuZXcgV2ViR1BVRW5naW5lKGNhbnZhcylcclxuICAgICAgYXdhaXQgKGVuZ2luZSBhcyBXZWJHUFVFbmdpbmUpLmluaXRBc3luYygpXHJcbiAgICB9ZWxzZXtcclxuICAgICAgY29uc29sZS5sb2coXCJXZWJHUFUgaXMgbm90IHN1cHBvcnRlZCAob3IgdHVybmVkIG9uKSBmb3IgdGhpcyBicm93c2VyIVwiKVxyXG4gICAgICBlbmdpbmUgPSBuZXcgV2ViR1BVRW5naW5lKGNhbnZhcylcclxuICAgIH1cclxuICAgIHJldHVybiBlbmdpbmVcclxuICB9XHJcblxyXG4gIGlkID0gXCJCYWJ5bG9uXCJcclxuICBjYW52YXMhOiBIVE1MQ2FudmFzRWxlbWVudFxyXG5cclxuICBvbk1vdW50ID0gKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpID0+ICh0aGlzLmNhbnZhcyA9IGNhbnZhcylcclxuXHJcbiAgcmVuZGVyKCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgPD5cclxuICAgICAgICA8Y2FudmFzIGlkPXt0aGlzLmlkfSByZWY9e3RoaXMub25Nb3VudH0gc3R5bGU9e3N0eWxlfSAvPlxyXG4gICAgICA8Lz5cclxuICAgIClcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IHN0eWxlID0geyB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0LCBiYWNrZ3JvdW5kOiBcInRyYW5zcGFyZW50XCIgfSJdLCJuYW1lcyI6WyJSZWFjdCIsIlB1cmVDb21wb25lbnQiLCJBcmNSb3RhdGVDYW1lcmEiLCJTY2VuZSIsIldlYkdQVUVuZ2luZSIsIlZlY3RvcjMiLCJTaGFkZXJTdG9yZSIsIkNvbG9yNCIsIkJhYnlsb25JbnRlcmFjdGl2aXR5IiwiQmFieWxvblNjZW5lIiwiY29tcG9uZW50RGlkTW91bnQiLCJjb25zb2xlIiwiY2xlYXIiLCJzZXR1cCIsImNhbnZhcyIsInJlbmRlciIsImlkIiwicmVmIiwib25Nb3VudCIsInN0eWxlIiwiU2hhZGVyc1N0b3JlV0dTTCIsImVuZ2luZSIsImNyZWF0ZUVuZ2luZSIsInNjZW5lIiwiY2xlYXJDb2xvciIsImNhbWVyYSIsImluaXRpYWxpemUiLCJnZW5lcmF0ZUZyYW1lIiwiSXNTdXBwb3J0ZWRBc3luYyIsImluaXRBc3luYyIsImxvZyIsIndpZHRoIiwid2luZG93IiwiaW5uZXJXaWR0aCIsImhlaWdodCIsImlubmVySGVpZ2h0IiwiYmFja2dyb3VuZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./app/space/BabylonScene.tsx\n"));

/***/ })

}]);