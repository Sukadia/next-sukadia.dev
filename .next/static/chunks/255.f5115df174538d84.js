"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[255],{5619:function(n,e,r){r.r(e),r.d(e,{default:function(){return o}});var t=r(7437),i=r(2265),s=r(4672),a=r(3693);class o extends i.PureComponent{componentDidMount(){console.clear(),this.setup(this.canvas)}render(){return(0,t.jsx)(t.Fragment,{children:(0,t.jsx)("canvas",{id:this.id,ref:this.onMount,style:f})})}constructor(...n){super(...n),this.setup=async n=>{s.vGS.ShadersStoreWGSL.starsPixelShader="\n        uniform seed : f32;\n        uniform density : f32;\n        uniform brightness : f32;\n\n        fn rand(seed : vec2<f32>) -> f32 {\n            return fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453);\n        }\n\n        @fragment\n        fn main(input : FragmentInputs) -> FragmentOutputs {\n\n            let random = rand(input.vUV*uniforms.seed);\n            var brightness = 0.0;\n            if (random < uniforms.density){\n                brightness = random/uniforms.density*uniforms.brightness;\n            }\n            //fragmentOutputs.color = vec4(1., 1., 1., brightness);\n            fragmentOutputs.color = vec4(brightness, brightness, brightness, 1.);\n        }\n    ",s.vGS.ShadersStoreWGSL.nebulasPixelShader="\n        var textureSampler: texture_2d<f32>;\n        var textureSamplerSampler: sampler;\n\n        uniform seed: f32;\n        uniform color: vec4<f32>;\n        uniform nebulascale: u32;\n        uniform depth: u32;\n        uniform intensity: f32;\n        uniform falloff: f32;\n        uniform persistence: f32;\n\n        fn mod289(x: vec2<f32>) -> vec2<f32> {\n            return x - floor(x * (1. / 289.)) * 289.;\n        }\n        \n        fn mod289_3(x: vec3<f32>) -> vec3<f32> {\n            return x - floor(x * (1. / 289.)) * 289.;\n        }\n        \n        fn permute3(x: vec3<f32>) -> vec3<f32> {\n            return mod289_3(((x * 34.) + 1.) * x);\n        }\n        \n        //  MIT License. \xa9 Ian McEwan, Stefan Gustavson, Munrocket\n        fn simplexNoise2(v: vec2<f32>) -> f32 {\n            let C = vec4(\n                0.211324865405187, // (3.0-sqrt(3.0))/6.0\n                0.366025403784439, // 0.5*(sqrt(3.0)-1.0)\n                -0.577350269189626, // -1.0 + 2.0 * C.x\n                0.024390243902439 // 1.0 / 41.0\n            );\n        \n            // First corner\n            var i = floor(v + dot(v, C.yy));\n            let x0 = v - i + dot(i, C.xx);\n        \n            // Other corners\n            var i1 = select(vec2(0., 1.), vec2(1., 0.), x0.x > x0.y);\n        \n            // x0 = x0 - 0.0 + 0.0 * C.xx ;\n            // x1 = x0 - i1 + 1.0 * C.xx ;\n            // x2 = x0 - 1.0 + 2.0 * C.xx ;\n            var x12 = x0.xyxy + C.xxzz;\n            x12.x = x12.x - i1.x;\n            x12.y = x12.y - i1.y;\n        \n            // Permutations\n            i = mod289(i); // Avoid truncation effects in permutation\n        \n            var p = permute3(permute3(i.y + vec3(0., i1.y, 1.)) + i.x + vec3(0., i1.x, 1.));\n            var m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), vec3(0.));\n            m *= m;\n            m *= m;\n        \n            // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n            // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n            let x = 2. * fract(p * C.www) - 1.;\n            let h = abs(x) - 0.5;\n            let ox = floor(x + 0.5);\n            let a0 = x - ox;\n        \n            // Normalize gradients implicitly by scaling m\n            // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n            m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n        \n            // Compute final noise value at P\n            let g = vec3(a0.x * x0.x + h.x * x0.y, a0.yz * x12.xz + h.yz * x12.yw);\n            return 130. * dot(m, g);\n        }\n\n        fn normalNoise(v: vec2<f32>) -> f32 {\n            return simplexNoise2(v)*0.5 + 0.5;\n        }\n\n        @fragment\n        fn main(input : FragmentInputs) -> FragmentOutputs {\n            let sampleColor = textureSample(textureSampler,textureSamplerSampler,fragmentInputs.vUV);\n\n            var offset = 0.;\n            let scaledUV = (input.vUV+offset+uniforms.seed)*f32(uniforms.nebulascale)/uniforms.scale;\n\n            var displace = 0.;\n            var i=u32(0);\n            for (i=0; i<uniforms.depth; i++){\n                displace = normalNoise(scaledUV*pow(uniforms.persistence,f32(i+1))+displace);\n            }\n            var finalTransparency = normalNoise(scaledUV+displace);\n            finalTransparency = pow(max(finalTransparency+uniforms.intensity,0), uniforms.falloff);\n\n            fragmentOutputs.color = mix(sampleColor,uniforms.color,finalTransparency);\n        }\n    ";let e=await this.createEngine(n),r=new s.xsS(e);r.clearColor=new s.HEv(0,0,0,0);let t=new s.YfP("camera",0,0,0,new s.Pa4(0,0,0),r);a.Z.initialize(n,e,r,t),a.Z.generateFrame()},this.createEngine=async n=>{let e;return await s.fWK.IsSupportedAsync?(e=new s.fWK(n),await e.initAsync()):(console.log("WebGPU is not supported (or turned on) for this browser!"),e=new s.fWK(n)),e},this.id="Babylon",this.onMount=n=>this.canvas=n}}let f={width:window.innerWidth,height:window.innerHeight,background:"transparent"}}}]);